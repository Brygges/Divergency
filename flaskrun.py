from flask import Flask, send_file, abort, request, jsonify
import os
import logging
from typing import Dict
import sys
import threading
import webbrowser
from pathlib import Path
import subprocess
import json
import tempfile
import shutil

# Determine base path
if getattr(sys, 'frozen', False):
    base_path = sys._MEIPASS
else:
    base_path = os.path.dirname(os.path.abspath(__file__))

# Configure logging and PATH
foldseek_dir = os.path.join(base_path, "foldseek", "bin")
os.environ["PATH"] = foldseek_dir + os.pathsep + os.environ.get("PATH", "")
logging.basicConfig(level=logging.DEBUG) if 'tlogging' in globals() else logging.basicConfig(level=logging.DEBUG)

# Load node_clusters mapping (generated by networkz.py)
clusters_json = os.path.join(base_path, "node_clusters.json")
if not os.path.exists(clusters_json):
    raise FileNotFoundError(f"node_clusters.json not found at {clusters_json}")
with open(clusters_json, "r") as f:
    NODE_CLUSTERS: Dict[str, int] = json.load(f)

# Path to prebuilt Foldseek DB (build with: foldseek createdb AllSpecies/ allspecies_db)
FOLDSEEK_DB = os.path.join(base_path, "AllSpecies")
if not os.path.exists(FOLDSEEK_DB):
    raise FileNotFoundError(f"Foldseek DB not found at {FOLDSEEK_DB}")

# Initialize Flask app
app = Flask(__name__)

@app.route('/')
def index():
    return send_file(os.path.join(base_path, "index.html"))

@app.route('/shutdown', methods=['POST'])
def shutdown():
    func = request.environ.get('werkzeug.server.shutdown')
    if func is None:
        abort(500, 'Not running with the Werkzeug Server')
    func()
    return 'Server shutting down...'

@app.route('/data.json')
def data_json():
    return send_file(os.path.join(base_path, "data.json"))

@app.route('/get_pdb/<node>')
def get_pdb(node):
    pdb_path = os.path.join(base_path, "AllSpecies", f"{node}.pdb")
    if os.path.exists(pdb_path):
        return send_file(pdb_path, mimetype='text/plain')
    abort(404, "PDB file not found")

@app.route('/superposed/<path:filename>')
def serve_superposed(filename):
    super_path = os.path.join(base_path, "Superposed", filename)
    if os.path.exists(super_path):
        return send_file(super_path, mimetype='text/plain')
    abort(404, "Superposed PDB file not found")

@app.route('/images/<path:filename>')
def images(filename):
    image_path = os.path.join(base_path, "images", filename)
    if os.path.exists(image_path):
        return send_file(image_path, mimetype="image/x-icon")
    abort(404, "Image not found")

@app.route('/classify', methods=['POST'])
def classify():
    # Validate upload
    f = request.files.get('file')
    if f is None or not f.filename.lower().endswith(('.pdb', '.cif')):
        abort(400, "No PDB/mmCIF uploaded")

    # Create temp directory and save file
    tmp_dir = tempfile.mkdtemp(prefix="foldseek_query_")
    try:
        upload_path = os.path.join(tmp_dir, f.filename)
        f.save(upload_path)
        logging.debug(f"Saved upload to {upload_path}")

        # Run Foldseek easy-search: output to results.m8, use tmp_dir for workdir
        results_m8 = os.path.join(tmp_dir, "results.m8")
        cmd = [
            "foldseek", "easy-search",
            tmp_dir,
            FOLDSEEK_DB,
            results_m8,
            tmp_dir,           # work directory
            "--threads", "4",
            "--format-output", "query,target,evalue,bits"
        ]
        logging.debug(f"Running Foldseek command: {' '.join(cmd)}")
        proc = subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.PIPE)
        if proc.returncode != 0:
            err = proc.stderr.decode()
            logging.error(f"Foldseek easy-search failed: {err}")
            abort(500, f"Foldseek easy-search failed: {err}")

        # Parse results
        hits = []
        with open(results_m8) as fh:
            for line in fh:
                if line.startswith('#'): continue
                cols = line.strip().split()
                try:
                    evalue = float(cols[2])
                    bitscore = float(cols[3])
                except (IndexError, ValueError):
                    continue
                hits.append((cols[0], cols[1], evalue, bitscore))

        if not hits:
            logging.warning("No hits returned by Foldseek.")
            abort(404, "No Foldseek hits found.")

        # Take top 5 by e-value
        hits = sorted(hits, key=lambda x: x[2])[:5]

        # Map targets to clusters
        cluster_counts = {}
        for _, target, evalue, bitscore in hits:
            cid = NODE_CLUSTERS.get(target)
            if cid is not None:
                cluster_counts[cid] = cluster_counts.get(cid, 0) + 1

        if not cluster_counts:
            logging.warning("No cluster mapping for any hit.")
            abort(404, "No cluster mapping found for hits.")

        best_cluster = max(cluster_counts, key=cluster_counts.get)

        # Prepare JSON response
        response_hits = []
        for query, target, evalue, bitscore in hits:
            response_hits.append({
                "target": target,
                "evalue": evalue,
                "bitscore": bitscore,
                "cluster": NODE_CLUSTERS.get(target)
            })

        # Identify representative hit for best cluster (lowest evalue)
        best_hit = next((h for h in hits if NODE_CLUSTERS.get(h[1]) == best_cluster), None)
        if best_hit:
            _, best_target, best_evalue, best_bitscore = best_hit
        else:
            best_target = None
            best_evalue = None
            best_bitscore = None

        # Return keys matching client-side expectations
        return jsonify({
            'fold': f'Cluster {best_cluster}',
            'e_value': best_evalue,
            'cluster': best_cluster,
            'target': best_target,
            'bitscore': best_bitscore,
            'hits': response_hits
        })

    except Exception as e:
        logging.exception("Error in classify endpoint")
        abort(500, f"Unexpected error: {str(e)}")
    finally:
        shutil.rmtree(tmp_dir)

def open_browser():
    import time
    time.sleep(1)
    webbrowser.open("http://127.0.0.1:5000")

if __name__ == '__main__':
    threading.Thread(target=open_browser).start()
    app.run(debug=False)

# Where are your 3Di clusters stored?
#CLUSTERS_DIR = Path(os.path.join(os.path.dirname(__file__), "clusters"))
# Build & press the HMM database _once_ at startup:
#HMM_DB = build_hmm_db(CLUSTERS_DIR, Path(os.path.join(os.path.dirname(__file__), "all_folds")))
